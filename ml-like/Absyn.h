#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* C++ Abstract Syntax Interface generated by the BNF Converter.*/

/********************   TypeDef Section    ********************/
typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;
typedef char* Boolean;
typedef char* UIdent;


/********************   Forward Declarations    ********************/

struct ListDef_;
typedef struct ListDef_ *ListDef;
struct ListSimplePat_;
typedef struct ListSimplePat_ *ListSimplePat;
struct ListPatMatch_;
typedef struct ListPatMatch_ *ListPatMatch;
struct ListIdent_;
typedef struct ListIdent_ *ListIdent;
struct ListType_;
typedef struct ListType_ *ListType;
struct ListDataCon_;
typedef struct ListDataCon_ *ListDataCon;
struct Program_;
typedef struct Program_ *Program;
struct Def_;
typedef struct Def_ *Def;
struct Const_;
typedef struct Const_ *Const;
struct Exp_;
typedef struct Exp_ *Exp;
struct SimplePat_;
typedef struct SimplePat_ *SimplePat;
struct PatMatch_;
typedef struct PatMatch_ *PatMatch;
struct Type_;
typedef struct Type_ *Type;
struct DataCon_;
typedef struct DataCon_ *DataCon;


/********************   Abstract Syntax Classes    ********************/

struct Program_
{

  enum { is_Prog } kind;
  union
  {
    struct { ListDef listdef_; } prog_;
  } u;
};

Program make_Prog(ListDef p0);

struct Def_
{

  enum { is_Define, is_Deftype, is_Data, is_DExp } kind;
  union
  {
    struct { Exp exp_; Ident ident_; } define_;
    struct { Ident ident_; Type type_; } deftype_;
    struct { ListDataCon listdatacon_; UIdent uident_; } data_;
    struct { Exp exp_; } dexp_;
  } u;
};

Def make_Define(Ident p0, Exp p1);
Def make_Deftype(Ident p0, Type p1);
Def make_Data(UIdent p0, ListDataCon p1);
Def make_DExp(Exp p0);

struct ListDef_
{
  Def def_;
  ListDef listdef_;
};

ListDef make_ListDef(Def p1, ListDef p2);
struct Const_
{

  enum { is_CInt, is_CFloat, is_CBool } kind;
  union
  {
    struct { Integer integer_; } cint_;
    struct { Double double_; } cfloat_;
    struct { Boolean boolean_; } cbool_;
  } u;
};

Const make_CInt(Integer p0);
Const make_CFloat(Double p0);
Const make_CBool(Boolean p0);

struct Exp_
{

  enum { is_EAdd, is_EMul, is_EConst, is_EVar, is_ELam, is_EMatch } kind;
  union
  {
    struct { Exp exp_1, exp_2; } eadd_;
    struct { Exp exp_1, exp_2; } emul_;
    struct { Const const_; } econst_;
    struct { Ident ident_; } evar_;
    struct { Exp exp_; ListIdent listident_; } elam_;
    struct { ListPatMatch listpatmatch_; } ematch_;
  } u;
};

Exp make_EAdd(Exp p0, Exp p1);
Exp make_EMul(Exp p0, Exp p1);
Exp make_EConst(Const p0);
Exp make_EVar(Ident p0);
Exp make_ELam(ListIdent p0, Exp p1);
Exp make_EMatch(ListPatMatch p0);

struct SimplePat_
{

  enum { is_SPConst, is_SPIdent } kind;
  union
  {
    struct { Const const_; } spconst_;
    struct { Ident ident_; } spident_;
  } u;
};

SimplePat make_SPConst(Const p0);
SimplePat make_SPIdent(Ident p0);

struct PatMatch_
{

  enum { is_PSimple, is_PData } kind;
  union
  {
    struct { Exp exp_; SimplePat simplepat_; } psimple_;
    struct { Exp exp_; Ident ident_; ListSimplePat listsimplepat_; } pdata_;
  } u;
};

PatMatch make_PSimple(SimplePat p0, Exp p1);
PatMatch make_PData(Ident p0, ListSimplePat p1, Exp p2);

struct ListSimplePat_
{
  SimplePat simplepat_;
  ListSimplePat listsimplepat_;
};

ListSimplePat make_ListSimplePat(SimplePat p1, ListSimplePat p2);
struct ListPatMatch_
{
  PatMatch patmatch_;
  ListPatMatch listpatmatch_;
};

ListPatMatch make_ListPatMatch(PatMatch p1, ListPatMatch p2);
struct Type_
{

  enum { is_TLam, is_TInt, is_TBool, is_TVar } kind;
  union
  {
    struct { Type type_1, type_2; } tlam_;
    struct { Ident ident_; } tvar_;
  } u;
};

Type make_TLam(Type p0, Type p1);
Type make_TInt(void);
Type make_TBool(void);
Type make_TVar(Ident p0);

struct ListIdent_
{
  Ident ident_;
  ListIdent listident_;
};

ListIdent make_ListIdent(Ident p1, ListIdent p2);
struct ListType_
{
  Type type_;
  ListType listtype_;
};

ListType make_ListType(Type p1, ListType p2);
struct DataCon_
{

  enum { is_Cnstr } kind;
  union
  {
    struct { ListType listtype_; UIdent uident_; } cnstr_;
  } u;
};

DataCon make_Cnstr(UIdent p0, ListType p1);

struct ListDataCon_
{
  DataCon datacon_;
  ListDataCon listdatacon_;
};

ListDataCon make_ListDataCon(DataCon p1, ListDataCon p2);


#endif
